[server]
[http]
enabled = false

doc_root = /usr/share/snapserver/snapweb

[tcp]
#enabled = true

#bind_to_address = 0.0.0.0
#port = 1705
[stream]
bind_to_address = 0.0.0.0

#port = 1704

# Available types are:
# pipe: pipe:///<path/to/pipe>?name=<n>[&mode=create], mode can be "create" or "read"

# file: file:///<path/to/PCM/file>?name=<n>

# Example MPV streaming sources (replace with your own URLs):
# source = process:///usr/bin/mpv?name=Stream1&sampleformat=44100:16:2&params=https://your-stream-url-here --no-terminal --audio-display=no --volume=80 --audio-channels=stereo --audio-samplerate=44100 --audio-format=s16 --ao=pcm --ao-pcm-file=/dev/stdout
# source = process:///usr/bin/mpv?name=Stream2&sampleformat=44100:16:2&params=https://your-stream-url-here --no-terminal --audio-display=no --volume=80 --audio-channels=stereo --audio-samplerate=44100 --audio-format=s16 --ao=pcm --ao-pcm-file=/dev/stdout

# Example pipe source for AirPlay or other inputs:
source = pipe:///tmp/snapfifo?name=AirPlay

# Default sample format: <sample rate>:<bits per sample>:<channels>
sampleformat = 44100:16:2

# Default transport codec
# (flac|ogg|opus|pcm)[:options]
# Start Snapserver with "--stream:codec=<codec>:?" to get codec specific options
codec = flac

# Default source stream read chunk size [ms].
# The server will continously read this number of milliseconds from the source into buffer and pass this buffer to the encoder.
# The encoded buffer is sent to the clients. Some codecs have a higher latency and will need more data, e.g. Flac will need ~26ms chunks
chunk_ms = 26

# Buffer [ms]
# The end-to-end latency, from capturing a sample on the server until the sample is played-out on the client
buffer = 150

# Send audio to muted clients
#send_to_muted = false
#
# Streaming client options ####################################################
#
[streaming_client]

# Volume assigned to new snapclients [percent]
# Defaults to 100 if unset
#initial_volume = 100
#
###############################################################################


# Logging options #############################################################
#
[logging]

# log sink [null,system,stdout,stderr,file:<filename>]
# when left empty: if running as daemon "system" else "stdout"
#sink =

# log filter <tag>:<level>[,<tag>:<level>]*
# with tag = * or <log tag> and level = [trace,debug,info,notice,warning,error,fatal]
#filter = *:info
#
############################################################################### 

